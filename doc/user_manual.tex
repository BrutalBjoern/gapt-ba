\documentclass[a4paper,11pt]{article}
\usepackage[utf8]{inputenc}
%\usepackage{fullpage}
\usepackage{listings}
\usepackage{color}
\usepackage{url}
\usepackage{alltt}
\usepackage{multicol}
\usepackage{fancyhdr}
\usepackage{amsmath}
\usepackage{bussproofs}
\usepackage{comment}
\usepackage{hyperref}

\renewcommand{\familydefault}{\sfdefault} % change to sans serif font

\newcommand{\seq}{\vdash}	% the sequent sign
\newcommand{\impl}{\supset} %logical connectives: implies, not, and, or
\renewcommand{\lnot}{\neg}
\renewcommand{\land}{\wedge}
\renewcommand{\lor}{\vee}
\newcommand{\sklabel}[2]{\langle#1\rangle^{#2}}

%Commands for constructing proof trees with bussproofs. See the chapter on the LK system for examples.
\newcommand{\UnaryInfCm}[1]{\UnaryInfC{$#1$}}
\newcommand{\BinaryInfCm}[1]{\BinaryInfC{$#1$}}
\newcommand{\RightLabelm}[1]{\RightLabel{$#1$}}
\newcommand{\AxiomCm}[1]{\AxiomC{$#1$}}

% Normal text in math mode ("math text")
\newcommand{\mt}[1]{\textnormal{#1}}
% CLI-style names,words,... within normal text
\newcommand{\cli}[1]{{\tt {#1}}}

% 
% activate meta-comments only when working on the user manual
%
\newenvironment{meta}{\color{red}}{\color{black}} % display meta-comments
%\excludecomment{meta} % do not display meta-comments
%
% import package for fixme notes
\usepackage[draft]{fixme}

\definecolor{LightGray}{rgb}{0.9,0.9,0.9}
\lstset{
  backgroundcolor=\color{LightGray},
  basicstyle=\footnotesize\ttfamily,
  breaklines=true,
  frame=single,
  inputencoding=utf8,
  extendedchars=true,
  literate=%
    {∧}{{\ensuremath{\land}}}1%
    {⊃}{{\ensuremath{\impl}}}1%
    {∨}{{\ensuremath{\lor}}}1%
    {¬}{{\ensuremath{\neg}}}1%
    {∀}{{\ensuremath{\forall}}}1%
    {∃}{{\ensuremath{\exists}}}1%
    {ι}{{\ensuremath{\iota}}}1%
    {α}{{\ensuremath{\alpha}}}1%
    {τ}{{\ensuremath{\tau}}}1%
  }
\lstnewenvironment{clilisting}{}{}

\setlength{\parindent}{0pt}
\setlength{\parskip}{4pt}
\setlength{\headheight}{14pt}
\setlength{\oddsidemargin}{1pt}
\setlength{\textwidth}{450pt}
%\setlength{\textheight}{600pt}

\pagestyle{fancy}
\lhead{GAPT -- User Manual}
\chead{}
\rhead{}

\begin{document}

\begin{titlepage}
\begin{center}

\hrule

\vspace*{20mm}

{\Huge GAPT}

\vspace*{5mm}

{\huge General Architecture for Proof Theory}

\vspace*{20mm}

{\Huge User Manual}

\vspace*{50mm}

{\Large \today}

\vspace*{20mm}

% {\Large
% % Whenever you contribute for this manual, include your name here
% % (alphabetically by last name) :)
% Stefan Hetzl - \texttt{stefan.hetzl@tuwien.ac.at}\\
% Bernhard Mallinger - \texttt{bernhard@logic.at}\\
% Giselle Reis - \texttt{giselle@logic.at}\\
% Janos Tapolczai - \texttt{e0825077@student.tuwien.ac.at}\\
% Daniel Weller - \texttt{weller@logic.at}
% }

\vspace*{60mm}

\hrule
\end{center}



\end{titlepage}

\tableofcontents
\vfill
\pagebreak

\section{Introduction}

GAPT is a generic architecture for proof transformations implemented in Scala.
Formulas, terms, and other expressions are are represented as lambda terms in
simple type theory.  Terms and formulas of first-order logic and schematic
first-order logic are hence encoded as lambda terms, these form regular
subsets.

The focus of GAPT are proof transformations (in contrast to proof assistants,
whose focus is proof formalization, and automated deduction systems, whose focus
is proof search). GAPT is used from a shell that provides access to the functionality
in the system in a way that is inspired by computer algebra systems: the basic
objects are formulas and (different kinds of) proofs which can be modified
by calling GAPT commands from the command line. In addition, there
is a graphical user interface that allows the user to view (and—to a certain extent—
modify) proofs in a flexible and visually appealing way.

The current functionality of GAPT includes data structures for formulas,
sequents, resolution proofs, sequent calculus proofs, expansion tree proofs
and algorithms for e.g.\ unification, proof skolemization, cut elimination,
cut elimination by resolution~\cite{Baaz00CutElimination}, cut introducton~\cite{Hetzl2012}, etc.

This document describes the system from the perspective of a user who has
downloaded a jar-file. For information on how to get started as a developer,
please see the developer wiki at \url{https://github.com/gapt/gapt/wiki}.

\begin{meta}
Meta-comments about this user guide are printed like this.
\end{meta}

\section{System Requirements}
\label{sec:sysreq}

To run GAPT you need to have Java 7 (or higher) installed.

GAPT contains interfaces to the following automated reasoning systems. Installing
them is optional. If GAPT does not find the executables in the path, the
functionality of these systems will not be available. 
%
\begin{itemize}
\item Prover9 (\url{http://www.cs.unm.edu/~mccune/mace4/download/}) - make sure
the commands \texttt{prover9}, \texttt{prooftrans} and \texttt{tptp\_to\_ladr}
are available.
\item E theorem prover (\url{http://eprover.org/})
\item LeanCoP (\url{http://leancop.de/})
\item VeriT (\url{http://www.verit-solver.org/})
\item Z3 (\url{https://github.com/Z3Prover/z3})
\item MiniSAT (\url{http://minisat.se/})
\item Glucose (\url{http://www.labri.fr/perso/lsimon/glucose/})
\item Sat4J (\url{http://sat4j.org/})
\item OpenWBO (\url{http://sat.inesc-id.pt/open-wbo/})
\end{itemize}

\section{Downloading and Running the System}

You can download a pre-packaged jar-file of the current version of GAPT
at~\url{http://www.logic.at/gapt/downloads}. After extracting 
the gapt-cli zip-file, you will find a shell script \texttt{cli.sh}.

Running this script
\begin{lstlisting}[mathescape=false]
 ./cli.sh
\end{lstlisting}
will start the command line interface of GAPT.

The command line interface of GAPT runs in an interactive Scala shell. This
means that all functionality of Scala is available to you. In
particular it is easy to write Scala scripts that use the functionality of GAPT.

Here are some useful things you should know about the Scala shell.

Scala uses both mutable and immutable variables. They are instantiated
with the keywords \texttt{var} and \texttt{val}, respectively.

If you want to assign the result of an expression to a variable, use
\texttt{var v = expr}. If you just write the expression, the system will 
automatically assign its value to a new variable.
You can see its name and type before the description, like this:

With a variable name:

\begin{clilisting}
gapt> var i = 12
i: Int = 12

\end{clilisting}

Without a variable name (in this case, the system created the variable \texttt{res12}):

\begin{clilisting}
gapt> 12
res0: Int = 12

\end{clilisting}

To see the value and type of a variable, just type its name and press enter.

Linked lists are implemented as the \texttt{List} type. The empty list is called \texttt{Nil}.
Lists are constructed like this:
\begin{clilisting}
gapt> List(1,2,3,4)
res1: List[Int] = List(1, 2, 3, 4)

\end{clilisting}

The ``cons'' operator \texttt{::} adds an item to the front of a list:
\begin{clilisting}
gapt> 0 :: List(1,2,3,4)
res2: List[Int] = List(0, 1, 2, 3, 4)

\end{clilisting}

You can use the \texttt{head} and \texttt{tail} methods to return the first
element and everything but the first element, respectively:

\begin{clilisting}
gapt> val l = List(1,2,3)
l: List[Int] = List(1, 2, 3)

gapt> l.head
res3: Int = 1

gapt> l.tail
res4: List[Int] = List(2, 3)

\end{clilisting}

It is also possible to refer to an element of a list directly by its index. Indices are
written in parentheses and begin at 0.

\begin{clilisting}
gapt> l(1)
res5: Int = 2

gapt> l(3)
java.lang.IndexOutOfBoundsException: 3
  at scala.collection.LinearSeqOptimized$class.apply(LinearSeqOptimized.scala:65)
  at scala.collection.immutable.List.apply(List.scala:84)
  ... 36 elided

\end{clilisting}

Unlike lists, tuples have a fixed length: While, for example, a list of integers may contain
any number of elements, a pair of integers always contains exactly two. Tuples are created
by enclosing their contents in parentheses:

\begin{clilisting}
gapt> val t = (1, 2, "hello")
t: (Int, Int, String) = (1,2,hello)

\end{clilisting}

As you can see, the type of t is \texttt{(Int, Int, String)}, indicating that it contains
exactly three elements, of which the first two are integers and the last is a string.

The $i$-th element of a tuple is accessed with the method \texttt{\_i}, like this:

\begin{clilisting}
gapt> t._1
res7: Int = 1

gapt> t._3
res8: String = hello

\end{clilisting}

To quit the interactive shell, just type \texttt{:quit} and press enter.

\fxnote{TODO: explain help command}

\section{File Input/Output}\label{sec.fileio}

\begin{meta}
TODO: first some general talk on file formats, then: give examples for saving and loading
proofs.
\end{meta}

This method \texttt{XMLProofDatabaseParser} will take as an argument a string that represents the path of a file
containing a proof database in the xml format (generated by HLK, for example) and
will return a proof database containing a list 
of pairs. It expects a file (the string of a proof will not work) and you can use 
the relative path. In the list returned, each pair is composed of a string and 
an object representing a proof within the system. The string is the name of the 
proof defined in the xml file. For example:
%
\begin{clilisting}
gapt> val proofs = XMLProofDatabaseParser( "examples/simple/fol1.xml.gz" ).proofs
proofs: List[(String, at.logic.gapt.proofs.lk.base.LKProof)] = List((p,CutRuleType(∀x.∀y.(P(x,y)⊃Q(x,y)) :- ∃x.∃y.(¬Q(x,y)⊃¬P(x,y)))))

\end{clilisting}
%
returns a list of length 1 as shown by entering
%
\begin{clilisting}
gapt> proofs.length
res9: Int = 1

\end{clilisting}
%
Its only element is \cli{proofs(0)}, the name of this proof can be obtained by
entering
%
\begin{clilisting}
gapt> proofs(0)._1
res10: String = p

\end{clilisting}
%
and the proof itself by
%
\begin{clilisting}
gapt> val proof = lkOld2New(proofs(0)._2)
proof: at.logic.gapt.proofs.lkNew.LKProof =
[p25] ∀x.∀y.(P(x,y)⊃Q(x,y)) :- ∃x.∃y.(¬Q(x,y)⊃¬P(x,y))    (CutRule(p24, Suc(0), p23, Ant(0)))
[p24] ∀x.∀y.(P(x,y)⊃Q(x,y)) :- ∀x.∃y.(¬P(x,y)∨Q(x,y))    (ForallRightRule(p22, Suc(0), z, x))
[p23] ∀x.∃y.(¬P(x,y)∨Q(x,y)) :- ∃x.∃y.(¬Q(x,y)⊃¬P(x,y))    (ForallLeftRule(p21, Ant(0), ∃y.(¬P(x,y)∨Q(x,y)), b, x))
[p22] ∀x.∀y.(P(x,y)⊃Q(x,y)) :- ∃y.(¬P(z,y)∨Q(z,y))    (ExistsRightRule(p20, Suc(0), (¬P(z,y)∨Q(z,y)), a, y))
[p21] ∃y.(¬P(b,y)∨Q(b,y)) :- ∃x.∃y.(¬Q(x,y)⊃¬P(x,y))    (ExistsLeftRule(p19, Ant(0), v, y))
[p20] ∀x.∀y.(P(x,y)⊃Q(x,y)) :- (¬P(z,a)∨Q(z,a))    (ForallLeftRule(p18, Ant(0), ∀y.(P(x,y)⊃Q(x,y)), z, x))
[p19] (¬P(b,v)∨Q(b,v)) :- ∃x.∃y.(¬Q(x,y)⊃¬P(x,y))    (ExistsRightRule(p17, Suc(0), ∃y.(¬Q(x,y)⊃¬P(x,y)), b, x))
[p18] ∀y.(P(z,y)⊃Q(z,y)) :- (...
\end{clilisting}
%
You can then view this proof in the graphical user interface \texttt{prooftool} by 
entering
%
\begin{clilisting}
gapt> prooftool( proof )

\end{clilisting}
%
In the folder \cli{../examples/simple} you can find a number of further simple
examples that illustrate different aspects of GAPT.


The command \texttt{saveXML} exports several proofs to an XML file.\fxnote{Fails (see latex comment)}
% 
% 
% scala> val p = LinearExampleProof( 3 )
% p: at.logic.gapt.proofs.lkNew.LKProof =
% [p14] ∀x.(P(x)⊃P(s(x))), P(0) :- P(s(s(s(0))))    (ContractionLeftRule(p13, Ant(0), Ant(2)))
% [p13] ∀x.(P(x)⊃P(s(x))), P(0), ∀x.(P(x)⊃P(s(x))) :- P(s(s(s(0))))    (ForallLeftRule(p12, Ant(0), (P(x)⊃P(s(x))), 0, x))
% [p12] (P(0)⊃P(s(0))), P(0), ∀x.(P(x)⊃P(s(x))) :- P(s(s(s(0))))    (ImpLeftRule(p11, Suc(0), p10, Ant(1)))
% [p11] P(0) :- P(0)    (LogicalAxiom(P(0)))
% [p10] ∀x.(P(x)⊃P(s(x))), P(s(0)) :- P(s(s(s(0))))    (ContractionLeftRule(p9, Ant(0), Ant(2)))
% [p9] ∀x.(P(x)⊃P(s(x))), P(s(0)), ∀x.(P(x)⊃P(s(x))) :- P(s(s(s(0))))    (ForallLeftRule(p8, Ant(0), (P(x)⊃P(s(x))), s(0), x))
% [p8] (P(s(0))⊃P(s(s(0)))), P(s(0)), ∀x.(P(x)⊃P(s(x))) :- P(s(s(s(0))))    (ImpLeftRule(p7, Suc(0), p6, Ant(1)))
% [p7] P(s(0)) :- P(s(0))    (LogicalAxiom(P(s(0))))
% [p6] ∀x.(P(...
% scala> saveXML( p::Nil, "first proof"::Nil, "result.xml" )
% <console>:102: error: overloaded method value apply with alternatives:
%   (proofs: List[(String, at.logic.gapt.proofs.lk.base.LKProof)],sequentlists: List[(String, List[at.logic.gapt.proofs.HOLSequent])],filename: String)Unit <and>
%   (ls: List[at.logic.gapt.proofs.lk.base.LKProof],names: List[String],outputFile: String)(implicit dummyImplicit: DummyImplicit)Unit
%  cannot be applied to (List[at.logic.gapt.proofs.lkNew.LKProof], List[String], String)
%        saveXML( p::Nil, "first proof"::Nil, "result.xml" )
% 
% 
The first argument is the list of proofs,
the second is the list of the names of the proofs and the third is the name of
the file that will be written. The file path can also be specified and it's
relative to where the program is being executed.

The code below exports the proofs in the variables $p1$ and $p2$ to the file
\texttt{result.xml} with names ``First proof'' and ``Second proof'',
respectively.
\begin{lstlisting}
gapt> saveXML(p1::p2::Nil, "First proof"::"Second proof"::Nil, "result.xml")
\end{lstlisting}

%\paragraph{\textbf{exportTPTP: List[Proof], List[String], String $\rightarrow$ Unit}}
%{\color{red}TODO}

\section{Entering Formulas}\label{sec.entering_formulas}
You can enter formulas by parsing them with the prover9\cite{Prover9Input} parser:
%
\begin{clilisting}
gapt> val H = parseFormula( "(all x (P(x,f(x)) -> (exists y P(x,y))))" )
H: at.logic.gapt.expr.FOLFormula = ∀x.(P(x,f(x))⊃∃y.P(x,y))

\end{clilisting}
%
The prover9 syntax was also extended to higher-order logic, where type declarations are added:
%
\begin{clilisting}
gapt> val I = HLKHOLParser.parseFormula ( "var P:o>i>o; const f:o>i; var x:o; var y:i; (all x (P(x,f(x))) -> (exists y P(x,y)))" )
I: at.logic.gapt.expr.HOLFormula = ∀x:o.(P(x,f(x))⊃∃y.P(x,y))

\end{clilisting}

Please refere to Appendix~\ref{app:formulasyntax} for a full description of the languages the parsers accept.

A collection of formula sequences can be found in the file \cli{examples/FormulaSequences.scala}.
Have a look at this code to see how to compose formulas without the parser.
You can generate instances of these formula sequences by entering, e.g.,
%
\begin{clilisting}
gapt> val f = BussTautology( 5 )
f: at.logic.gapt.proofs.HOLSequent = ((((((c_1∨d_1)∧(c_2∨d_2))∧(c_3∨d_3))∧(c_4∨d_4))⊃c_5)∨(((((c_1∨d_1)∧(c_2∨d_2))∧(c_3∨d_3))∧(c_4∨d_4))⊃d_5)), (((((c_1∨d_1)∧(c_2∨d_2))∧(c_3∨d_3))⊃c_4)∨((((c_1∨d_1)∧(c_2∨d_2))∧(c_3∨d_3))⊃d_4)), ((((c_1∨d_1)∧(c_2∨d_2))⊃c_3)∨(((c_1∨d_1)∧(c_2∨d_2))⊃d_3)), (((c_1∨d_1)⊃c_2)∨((c_1∨d_1)⊃d_2)), (c_1∨d_1) :- c_5, d_5

\end{clilisting}



\section{Automated Deduction}
  
\subsection{SAT Solving}
%
The following shows an example session, using the MiniSAT solver
to verify valdity and satisfiability, and query the thus obtained models.
Consider the {\em pigeon hole principle for $(m, n)$, $\mathrm{PHP}_{m,n}$}, which states that if $m$ pigeons
are put into $n$ holes, then there is a hole which contains two pigeons. It is valid
iff $m>n$. $\neg\mathrm{PHP}_{m,n}$ states that when putting $m$ pigeons into $n$ holes, there
is no hole containing two pigeons. This is satisfiable iff $m\leq n$.
\begin{clilisting}
gapt> MiniSAT.isValid(PigeonHolePrinciple(3, 2))
res12: Boolean = true

\end{clilisting}
shows that $\mathrm{PHP}_{3,2}$ is valid, and
\begin{clilisting}
gapt> MiniSAT.isValid(PigeonHolePrinciple(3, 3))
res13: Boolean = false

\end{clilisting}
shows that $\mathrm{PHP}_{3,3}$ is not valid.
Furthermore,
\begin{clilisting}
gapt> val Some(m) = MiniSAT.solve(Neg(PigeonHolePrinciple(3, 3)))
m: at.logic.gapt.models.Interpretation =
R(p_1,h_1) -> false
R(p_1,h_2) -> true
R(p_1,h_3) -> false
R(p_2,h_1) -> true
R(p_2,h_2) -> false
R(p_2,h_3) -> false
R(p_3,h_1) -> false
R(p_3,h_2) -> false
R(p_3,h_3) -> true

\end{clilisting}
yields a model of $\neg\mathrm{PHP}_{3,3}$ that can be queried:
\begin{clilisting}
gapt> val p1 = PigeonHolePrinciple.atom(1, 1)
p1: at.logic.gapt.expr.FOLAtom = R(p_1,h_1)

gapt> val p2 = PigeonHolePrinciple.atom(2, 1)
p2: at.logic.gapt.expr.FOLAtom = R(p_2,h_1)

gapt> val p3 = PigeonHolePrinciple.atom(3, 1)
p3: at.logic.gapt.expr.FOLAtom = R(p_3,h_1)

gapt> m.interpret(p1) // Is pigeon 1 in hole 1?
res14: Boolean = false

gapt> m.interpret(p2) // Is pigeon 2 in hole 1?
res15: Boolean = true

gapt> m.interpret(p3) // Is pigeon 3 in hole 1?
res16: Boolean = false

\end{clilisting}
We can also interpret quantifier-free formulas:
\begin{clilisting}
gapt> m.interpret( And(p1, p2) )
res17: Boolean = false

\end{clilisting}

\fxnote{explain how to use DIMACS export -- reader will ask: how can I use my favourite SAT solver}

\subsection{SMT Solving}

\fxnote{similar example as above for veriT}

\fxnote{explain how to use SMT-LIB export -- reader will ask: how can I use my favourite SMT-solver}

\subsection{First-Order Theorem Proving}

\fxnote{similar example as in SAT-case for prover9}

\fxnote{explain how to use TPTP export -- reader will ask: how can I use my favourite resolution theorem prover}

% \subsection{Built-In Resolution Prover}
% 
% GAPT contains a built-in resultion prover that can be called with the command:
% \texttt{refuteFOL: Seq[Clause] $\rightarrow$ Option[ResolutionProof[Clause]]}
% and with the command
% \texttt{refuteFOLI: Seq[Clause] $\rightarrow$ Option[ResolutionProof[Clause]]}
% for interactive mode.

\subsection{Built-In Tableaux Prover}

GAPT contains a  built-in tableaux prover for propositional logic
which can be called with the command \texttt{solve.solvePropositional}, for example as in\fxnote{do not use SimpleFOLParser}:
\begin{clilisting}
gapt> solve.solvePropositional( SimpleFOLParser( "Imp A Imp B And A B" ))
res18: Option[at.logic.gapt.proofs.lkNew.LKProof] =
Some([p5]  :- (A⊃(B⊃(A∧B)))    (ImpRightRule(p4, Ant(0), Suc(0)))
[p4] A :- (B⊃(A∧B))    (ImpRightRule(p3, Ant(1), Suc(0)))
[p3] A, B :- (A∧B)    (AndRightRule(p2, Suc(0), p1, Suc(0)))
[p2] A :- A    (LogicalAxiom(A))
[p1] B :- B    (LogicalAxiom(B))
)

\end{clilisting}

\section{Entering Proofs}\label{sec:entering_proofs}

There are various possibilities for entering proofs into the system. The most
basic one is a direct top-down proof-construction using the constructors
of the inference rules. For example, continuing in the environment of
Section~\ref{sec.entering_formulas}\fxnote{sections should be self-contained,
Section~\ref{sec.entering_formulas} does not contain $F$}, suppose that we want to enter a
proof of \texttt{F}. It is convenient to prepare the subformulas first.
\begin{clilisting}
gapt> val A = FOLAtom("A")
A: at.logic.gapt.expr.FOLAtom = A

gapt> val B = FOLAtom("B")
B: at.logic.gapt.expr.FOLAtom = B

gapt> val F1 = B --> (A & B)
F1: at.logic.gapt.expr.FOLFormula = (B⊃(A∧B))

gapt> val F2 = A & B
F2: at.logic.gapt.expr.FOLFormula = (A∧B)

\end{clilisting}
%
We start with the axioms:
%
\begin{clilisting}
gapt> val p1 = LogicalAxiom(A)
p1: at.logic.gapt.proofs.lkNew.LogicalAxiom =
[p1] A :- A    (LogicalAxiom(A))

gapt> val p2 = LogicalAxiom(B)
p2: at.logic.gapt.proofs.lkNew.LogicalAxiom =
[p1] B :- B    (LogicalAxiom(B))

\end{clilisting}
%
These are joined by an $\land:\mathrm{right}$-inference. See Appendix~\ref{app:sequent_calculus}
for the formal definition of the sequent calculus used in GAPT.
\begin{clilisting}
gapt> val p3 = AndRightRule( p1, A, p2, B )
p3: at.logic.gapt.proofs.lkNew.AndRightRule =
[p3] A, B :- (A∧B)    (AndRightRule(p2, Suc(0), p1, Suc(0)))
[p2] A :- A    (LogicalAxiom(A))
[p1] B :- B    (LogicalAxiom(B))

\end{clilisting}
%
To finish the proof it remains to apply two $\impl:\mathrm{right}$-inferences:
%
\begin{clilisting}
gapt> val p4 = ImpRightRule( p3, B, F2 )
p4: at.logic.gapt.proofs.lkNew.ImpRightRule =
[p4] A :- (B⊃(A∧B))    (ImpRightRule(p3, Ant(1), Suc(0)))
[p3] A, B :- (A∧B)    (AndRightRule(p2, Suc(0), p1, Suc(0)))
[p2] A :- A    (LogicalAxiom(A))
[p1] B :- B    (LogicalAxiom(B))

gapt> val p5 = ImpRightRule( p4, A, F1 )
p5: at.logic.gapt.proofs.lkNew.ImpRightRule =
[p5]  :- (A⊃(B⊃(A∧B)))    (ImpRightRule(p4, Ant(0), Suc(0)))
[p4] A :- (B⊃(A∧B))    (ImpRightRule(p3, Ant(1), Suc(0)))
[p3] A, B :- (A∧B)    (AndRightRule(p2, Suc(0), p1, Suc(0)))
[p2] A :- A    (LogicalAxiom(A))
[p1] B :- B    (LogicalAxiom(B))

\end{clilisting}
%
You can now view this proof by typing:
\begin{clilisting}
gapt> prooftool( p5 )

\end{clilisting}

The system comes with a collection of example proof sequences in the file
\cli{examples/ProofSequences.scala} which are generated in the above style.
Have a look at this code for more complicated proof constructions.


\section{Proof Theory}

\subsection{Cut-Elimination (Gentzen's method)}

The GAPT-system contains an implementation of reductive cut-elimination
\`{a} la Gentzen. It can be used as follows: first we load a proof p
with cuts (as in Section~\ref{sec.fileio}).
%
\begin{clilisting}
gapt> val p = lkOld2New(XMLProofDatabaseParser( "examples/simple/fol1.xml.gz" ).proofs(0)._2)
p: at.logic.gapt.proofs.lkNew.LKProof =
[p25] ∀x.∀y.(P(x,y)⊃Q(x,y)) :- ∃x.∃y.(¬Q(x,y)⊃¬P(x,y))    (CutRule(p24, Suc(0), p23, Ant(0)))
[p24] ∀x.∀y.(P(x,y)⊃Q(x,y)) :- ∀x.∃y.(¬P(x,y)∨Q(x,y))    (ForallRightRule(p22, Suc(0), z, x))
[p23] ∀x.∃y.(¬P(x,y)∨Q(x,y)) :- ∃x.∃y.(¬Q(x,y)⊃¬P(x,y))    (ForallLeftRule(p21, Ant(0), ∃y.(¬P(x,y)∨Q(x,y)), b, x))
[p22] ∀x.∀y.(P(x,y)⊃Q(x,y)) :- ∃y.(¬P(z,y)∨Q(z,y))    (ExistsRightRule(p20, Suc(0), (¬P(z,y)∨Q(z,y)), a, y))
[p21] ∃y.(¬P(b,y)∨Q(b,y)) :- ∃x.∃y.(¬Q(x,y)⊃¬P(x,y))    (ExistsLeftRule(p19, Ant(0), v, y))
[p20] ∀x.∀y.(P(x,y)⊃Q(x,y)) :- (¬P(z,a)∨Q(z,a))    (ForallLeftRule(p18, Ant(0), ∀y.(P(x,y)⊃Q(x,y)), z, x))
[p19] (¬P(b,v)∨Q(b,v)) :- ∃x.∃y.(¬Q(x,y)⊃¬P(x,y))    (ExistsRightRule(p17, Suc(0), ∃y.(¬Q(x,y)⊃¬P(x,y)), b, x))
[p18] ∀y.(P(z,y)⊃Q(z,y)) :- (¬P(z...
\end{clilisting}
%
and then call the cut-elimination procedure:
\begin{clilisting}
gapt> val q = ReductiveCutElimination( p )
q: at.logic.gapt.proofs.lkNew.LKProof =
[p16] ∀x.∀y.(P(x,y)⊃Q(x,y)) :- ∃x.∃y.(¬Q(x,y)⊃¬P(x,y))    (ForallLeftRule(p15, Ant(0), ∀y.(P(x,y)⊃Q(x,y)), b, x))
[p15] ∀y.(P(b,y)⊃Q(b,y)) :- ∃x.∃y.(¬Q(x,y)⊃¬P(x,y))    (ForallLeftRule(p14, Ant(0), (P(b,y)⊃Q(b,y)), a, y))
[p14] (P(b,a)⊃Q(b,a)) :- ∃x.∃y.(¬Q(x,y)⊃¬P(x,y))    (ContractionRightRule(p13, Suc(0), Suc(1)))
[p13] (P(b,a)⊃Q(b,a)) :- ∃x.∃y.(¬Q(x,y)⊃¬P(x,y)), ∃x.∃y.(¬Q(x,y)⊃¬P(x,y))    (ImpLeftRule(p12, Suc(0), p11, Ant(0)))
[p12]  :- P(b,a), ∃x.∃y.(¬Q(x,y)⊃¬P(x,y))    (ExistsRightRule(p10, Suc(1), ∃y.(¬Q(x,y)⊃¬P(x,y)), b, x))
[p11] Q(b,a) :- ∃x.∃y.(¬Q(x,y)⊃¬P(x,y))    (ExistsRightRule(p9, Suc(0), ∃y.(¬Q(x,y)⊃¬P(x,y)), b, x))
[p10]  :- P(b,a), ∃y.(¬Q(b,y)⊃¬P(b,y))    (ExistsRightRule(p8, Suc(1), (¬Q(b,y)⊃¬P(b,y)), a, y))
[p9] Q(b,a) :- ∃y.(¬...
\end{clilisting}


\subsection{Skolemization}

Skolemization consists of replacing the variables bound by strong quantifiers in the end-sequent of a proof
by new function symbols thus obtaining a validity-equivalent sequent. In the GAPT-system Skolemization
is implemented for proofs and can be used, e.g.~as follows:
%
\begin{clilisting}
gapt> val proofs = XMLProofDatabaseParser( "examples/prime/ceres_xml/prime1-1.xml.gz" ).proofs
proofs: List[(String, at.logic.gapt.proofs.lk.base.LKProof)] = List((the-proof,CutRuleType(PRIME-DIV, REM, PRE, F[1] :- )))

gapt> val p = proofs(0)._2
p: at.logic.gapt.proofs.lk.base.LKProof = CutRuleType(PRIME-DIV, REM, PRE, F[1] :- )

gapt> val q = skolemize( lkOld2New(p) )
q: at.logic.gapt.proofs.lkNew.LKProof =
[p968] F[1], PRIME-DIV, PRE, REM :-     (CutRule(p967, Suc(0), p966, Ant(0)))
[p967] F[1], PRIME-DIV, PRE, REM :- INF(set_1(1))    (CutRule(p965, Suc(0), p964, Ant(4)))
[p966] INF(set_1(1)) :-     (DefinitionLeftRule(p963, Ant(0), INF(set_1(1))))
[p965]  :- ¬empty(set_1(1))    (NegRightRule(p962, Ant(0)))
[p964] F[1], PRIME-DIV, PRE, REM, ¬empty(set_1(1)) :- INF(set_1(1))    (CutRule(p961, Suc(0), p960, Ant(0)))
[p963] ∀m.∃n.∈((m+(n+1)),set_1(1)) :-     (ForallLeftRule(p959, Ant(0), ∃n.∈((m+(n+1)),set_1(1)), 1, m))
[p962] empty(set_1(1)) :-     (DefinitionLeftRule(p958, Ant(0), empty(set_1(1))))
[p961] F[1], PRIME-DIV, PRE, REM :- O(set_1(1))    (CutRule(p957, Suc(0), p956, Ant(0)))
[p960] O(set_1(1)), ¬empty(set_1(1)) :- INF(set_1(1))    (CutRule...
\end{clilisting}


\subsection{Interpolation}

\fxwarning{Use a more reasonable example here.}

The command \texttt{ExtractInterpolant} extracts an interpolant from a sequent calculus proof which may contain atomic cuts and/or equality rules. Currently, we allow only reflexivity axioms or axioms of the form $A \seq A$. The implementation is based on Lemma 6.5 of~\cite{Takeuti87Proof}. The method expects
a proof p and an arbitrary partition of the end-sequent $\Gamma \seq \Delta$ of p into a 
``negative part'' $\Gamma_1\seq\Delta_1$ and a ``positive part'' $\Gamma_2 \seq \Delta_2$.
It returns a formula $I$ s.t.\ $\Gamma_1\seq\Delta_1, I$ and $I,\Gamma_2\seq\Delta_2$
are provable and $I$ contains only such predicate symbols that appear in both, $\Gamma_1\seq\Delta_1$
and $\Gamma_2\seq\Delta_2$. For example, suppose pr is a proof of $p \lor q \seq p, q$
by a single $\lor$-left inference (see Section~\ref{sec:entering_proofs} for how to construct
such a proof), then you can compute an interpolant as follows:
\begin{clilisting}
gapt> val pr: LKProof = p3
pr: at.logic.gapt.proofs.lkNew.LKProof =
[p3] A, B :- (A∧B)    (AndRightRule(p2, Suc(0), p1, Suc(0)))
[p2] A :- A    (LogicalAxiom(A))
[p1] B :- B    (LogicalAxiom(B))

gapt> val I = ExtractInterpolant(pr, Seq(Ant(0), Suc(0)), Seq(Ant(1)))
I: at.logic.gapt.expr.HOLFormula = (⊥∨¬B)

\end{clilisting}

\subsection{Expansion Trees}

Expansion trees are a compact representation of cut-free proofs. They have originally been
introduced in~\cite{Miller87Compact}. GAPT contains an implementation of
expansion trees for higher-order logic including functions for extracting expansion
trees from proofs, for merging expansion trees, for pruning and transforming them
in various ways and for viewing them in a comfortable way in the graphical user interface.

An expansion tree contains the instances of the quantifiers for a formula. In order
to represent an LK-proof we use {\em expansion sequents}, i.e.~sequents of expansion trees.
We can obtain an expansion sequent for example by:
\begin{clilisting}
gapt> val p = SquareEdgesExampleProof( 4 )
p: at.logic.gapt.proofs.lkNew.LKProof =
[p40] ∀x.∀y.(P(x,y)⊃P(s(x),y)), P(0,0), ∀x.∀y.(P(x,y)⊃P(x,s(y))) :- P(s(s(s(s(0)))),s(s(s(s(0)))))    (ContractionLeftRule(p39, Ant(0), Ant(2)))
[p39] ∀x.∀y.(P(x,y)⊃P(s(x),y)), P(0,0), ∀x.∀y.(P(x,y)⊃P(s(x),y)), ∀x.∀y.(P(x,y)⊃P(x,s(y))) :- P(s(s(s(s(0)))),s(s(s(s(0)))))    (ForallLeftRule(p38, Ant(0), ∀y.(P(x,y)⊃P(s(x),y)), 0, x))
[p38] ∀y.(P(0,y)⊃P(s(0),y)), P(0,0), ∀x.∀y.(P(x,y)⊃P(s(x),y)), ∀x.∀y.(P(x,y)⊃P(x,s(y))) :- P(s(s(s(s(0)))),s(s(s(s(0)))))    (ForallLeftRule(p37, Ant(0), (P(0,y)⊃P(s(0),y)), 0, y))
[p37] (P(0,0)⊃P(s(0),0)), P(0,0), ∀x.∀y.(P(x,y)⊃P(s(x),y)), ∀x.∀y.(P(x,y)⊃P(x,s(y))) :- P(s(s(s(s(0)))),s(s(s(s(0)))))    (ImpLeftRule(p36, Suc(0), p35, Ant(1)))
[p36] P(0,0) :- P(0,0)    (LogicalAxiom(P(0,0)))
[p35] ∀x.∀y.(P(x,y)⊃P(s(x),y)), P...
gapt> val E = LKToExpansionProof( p )
E: at.logic.gapt.proofs.expansionTrees.ExpansionSequent = WeakQuantifier(∀x.∀y.(P(x,y)⊃P(s(x),y)), List((WeakQuantifier(∀y.(P(0,y)⊃P(s(0),y)), List((Atom(P(0,0))⊃Atom(P(s(0),0)),0))),0), (WeakQuantifier(∀y.(P(s(0),y)⊃P(s(s(0)),y)), List((Atom(P(s(0),0))⊃Atom(P(s(s(0)),0)),0))),s(0)), (WeakQuantifier(∀y.(P(s(s(0)),y)⊃P(s(s(s(0))),y)), List((Atom(P(s(s(0)),0))⊃Atom(P(s(s(s(0))),0)),0))),s(s(0))), (WeakQuantifier(∀y.(P(s(s(s(0))),y)⊃P(s(s(s(s(0)))),y)), List((Atom(P(s(s(s(0))),0))⊃Atom(P(s(s(s(s(0)))),0)),0))),s(s(s(0)))))), Atom(P(0,0)), WeakQuantifier(∀x.∀y.(P(x,y)⊃P(x,s(y))), List((WeakQuantifier(∀y.(P(s(s(s(s(0)))),y)⊃P(s(s(s(s(0)))),s(y))), List((Atom(P(s(s(s(s(0)))),0))⊃Atom(P(s(s(s(s(0)))),s(0))),0), (Atom(P(s(s(s(s(0)))),s(0)))⊃Atom(P(s(s(s(s(0)))),s(s(0)))),s(0)), (Atom(P(s(s(s(s(...
\end{clilisting}
This expansion sequent can then be viewed in the graphical user interface by simply calling:
\begin{clilisting}
gapt> prooftool( E )

\end{clilisting}
Prooftool is then intialized with displaying the end-sequent of \cli{p}, i.e.\ the shallow sequent
of \cli{E}. The user can then selectively expand quantifiers by clicking on them, see~\cite{Hetzl13Understanding}
for a detailed description.


\section{Cut-Elimination by Resolution (CERES)}


\subsection{First-Order Logic}

\begin{meta}
The ceres-functionality should be demonstrated by an short example
\end{meta}

\subsection{Higher-Order Logic}

\begin{meta}
TODO
\end{meta}


\section{Cut-Introduction}

The cut-introduction algorithm as described in~\cite{Hetzl2012,Hetzl14Algorithmic,Hetzl14Introducing} is
implemented in GAPT for introducing $\Pi_1$-cuts into a sequent calculus
proof. We will use as input one of the proofs generated by
the system, namely, \texttt{LinearExampleProof(9)}. But the user can also
write his own proofs (see Section~\ref{sec:entering_proofs})
and input them to the cut-introduction algorithm.

Take an example proof:
\begin{clilisting}
gapt> val p = LinearExampleProof( 9 )
p: at.logic.gapt.proofs.lkNew.LKProof =
[p38] ∀x.(P(x)⊃P(s(x))), P(0) :- P(s(s(s(s(s(s(s(s(s(0))))))))))    (ContractionLeftRule(p37, Ant(0), Ant(2)))
[p37] ∀x.(P(x)⊃P(s(x))), P(0), ∀x.(P(x)⊃P(s(x))) :- P(s(s(s(s(s(s(s(s(s(0))))))))))    (ForallLeftRule(p36, Ant(0), (P(x)⊃P(s(x))), 0, x))
[p36] (P(0)⊃P(s(0))), P(0), ∀x.(P(x)⊃P(s(x))) :- P(s(s(s(s(s(s(s(s(s(0))))))))))    (ImpLeftRule(p35, Suc(0), p34, Ant(1)))
[p35] P(0) :- P(0)    (LogicalAxiom(P(0)))
[p34] ∀x.(P(x)⊃P(s(x))), P(s(0)) :- P(s(s(s(s(s(s(s(s(s(0))))))))))    (ContractionLeftRule(p33, Ant(0), Ant(2)))
[p33] ∀x.(P(x)⊃P(s(x))), P(s(0)), ∀x.(P(x)⊃P(s(x))) :- P(s(s(s(s(s(s(s(s(s(0))))))))))    (ForallLeftRule(p32, Ant(0), (P(x)⊃P(s(x))), s(0), x))
[p32] (P(s(0))⊃P(s(s(0)))), P(s(0)), ∀x.(P(x)⊃P(s(x))) :- P(s(s(s(s(s(s(s(s(s(0))...
\end{clilisting}
Then compute a proof with a single cut that contains a single quantifier by:
\begin{clilisting}
gapt> val q = CutIntroduction.compressLKProof( p, DeltaTableMethod( manyQuantifiers=false ), verbose=true )
Total inferences in the input proof: 36
Quantifier inferences in the input proof: 9
End sequent: ∀x.(P(x)⊃P(s(x))), P(0) :- P(s(s(s(s(s(s(s(s(s(0))))))))))
Size of term set: 11
Smallest grammar of size 8:
Axiom: (τ)
Non-terminal vectors:
  (τ)
  (α_0)
Productions:
  τ -> -{P(0)}_a1

  τ -> -{∀x.(P(x)⊃P(s(x)))}_a0(s(s(s(s(s(s(α_0)))))))

  τ -> -{∀x.(P(x)⊃P(s(x)))}_a0(s(s(s(α_0))))

  τ -> -{∀x.(P(x)⊃P(s(x)))}_a0(α_0)

  τ -> {P(s(s(s(s(s(s(s(s(s(0))))))))))}_s0

  α_0 -> 0

  α_0 -> s(0)

  α_0 -> s(s(0))


Size of the canonical solution: 12
Size of the minimized solution: 12
CNF of minimized cut-formula number 0:
  P(s(s(s(s(s(s(α_0))))))) :- P(s(s(s(s(s(s(s(α_0))))))))
  P(α_0) :- P(s(α_0))
  P(s(s(s(α_0)))) :- P(s(s(s(s(α_0)))))
Number of cuts introduced: 1
Total inferences in the proof with cut(s): 153
Quantifier inferences in the proof with cut(s): 7
q: Option[at.logic.gapt.proofs.lkNew.LKProof] =
Some([p95] ∀x.(P(x)⊃P(s(x))), P(0) :- P(s(s(s(s(s(s(s(s(s(0))))))))))    (CutRule(p94, Suc(0), p93, Ant(0)))
[p94] ∀x.(P(x)⊃P(s(x))) :- ∀α_0.(((P(s(s(s(s(s(s(α_0)))))))⊃P(s(s(s(s(s(s(s(α_0)))))))))∧(P(α_0)⊃P(s(α_0))))∧(P(s(s(s(α_0))))⊃P(s(s(s(s(α_0)))))))    (ForallRightRule(p92, Suc(0), α_0, α_0))
[p93] ∀α_0.(((P(s(s(s(s(s(s(α_0)))))))⊃P(s(s(s(s(s(s(s(α_0)))))))))∧(P(α_0)⊃P(s(α_0))))∧(P(s(s(s(α_0))))⊃P(s(s(s(s(α_0))))))), P(0) :- P(s(s(s(s(s(s(s(s(s(0))))))))))    (ContractionLeftRule(p91, Ant(1), Ant(0)))
[p92] ∀x.(P(x)⊃P(s(x))) :- (((P(s(s(s(s(s(s(α_0)))))))⊃P(s(s(s(s(s(s(s(α_0)))))))))∧(P(α_0)⊃P(s(α_0))))∧(P(s(s(s(α_0))))⊃P(s(s(s(s(α_0)))))))    (ContractionLeftRule(p90, Ant(1), Ant(0)))
[p91] ∀α_0.(((P(s(s(s(s(s(s(α_0)))))))⊃P(s(s(s(s...
\end{clilisting}
You can also try \texttt{DeltaTableMethod(manyQuantifiers=true)}, this will proceed as above but will
compute a single cut with a block of quantifiers.  The method \texttt{MaxSATMethod(1,2)}
uses a reduction to a MaxSAT problem and an external MaxSAT-solver for finding a
minimal grammar corresponding to a proof with a cut with two cuts, one with $1$
quantifer, one with $2$ quantifers.


% \section{Cut-Introduction -- OLD}
% 
% The cut-introduction algorithm as described in~\cite{Hetzl2012,Hetzl14Algorithmic,Hetzl14Introducing} is
% implemented in GAPT for introducing a single $\Pi_1$-cut into a sequent calculus
% proof. In this section we show the commands, step by step, that need to be
% executed for this algorithm. We will use as input one of the proofs generated by
% the system, namely, \texttt{LinearExampleProof(9)}. But the user can also
% write his own proofs (see Section~\ref{sec:entering_proofs})
% and input them files to the cut-introduction algorithm.
% 
% Make sure that the example proof sequences are available in the current CLI
% session if you have not done so already by entering
% \begin{lstlisting}
% gapt> :load examples/ProofSequences.scala
% \end{lstlisting}
% %
% First of all, we instantiate the desired proof and store this in a variable:
% \begin{lstlisting}
% gapt> val p = LinearExampleProof(9)
% \end{lstlisting}
% 
% You will see that a big string representing the proof is printed. If desired,
% you can view this proof using \texttt{prooftool}. 
% It is possible to see some information about a proof on the command line by calling:
% \begin{lstlisting}
% gapt> printProofStats(p)
% ------------- Statistics ---------------
% Cuts: 0
% Number of quantifier rules: 9
% Number of rules: 28
% Quantifier complexity: 9
% ----------------------------------------
% \end{lstlisting}
% Now we need to
% extract the terms used to instantiate the $\forall$ quantifiers of the
% end-sequent:
% \begin{lstlisting}
% gapt> val ts = extractTerms(p)
% \end{lstlisting}
% The system indicates how many terms were extracted, which is nine for this case,
% as expected. The next step consists in computing grammars that generate this
% term set:
% \begin{lstlisting}
% gapt> val grms = computeGrammars(ts)
% \end{lstlisting}
% The number of grammars found is shown, 26 in this case. This list of grammars is guaranteed
% to contain all grammars of minimal size (but not all grammars as the algorithm
% will not generate grammars larger than others already generated).
% The grammars are ordered by size, and one can see the first five by calling:
% \begin{lstlisting}
% gapt> grms.take(5) foreach println
% \end{lstlisting}
% This will print on the screen the first 5 grammars, and we can choose which one
% to use for compressing the proof, in this case we take the second one:
% \begin{lstlisting}
% gapt> val g = grms(1)
% \end{lstlisting}
% Given the end-sequent of the proof and a grammar, the extended Herbrand sequent can be computed:
% \begin{lstlisting}
% gapt> val ehs = generateExtendedHerbrandSequent(p.root, g)
% \end{lstlisting}
% As it was shown in~\cite{Hetzl2012}, the cut-introduction problem has a
% canonical solution:
% \begin{lstlisting}
% gapt> val cs = computeCanonicalSolution(p.root, g)
% \end{lstlisting}
% The extended Herbrand sequent generated previously has the canonical solution as
% default, but this solution can be improved.. 
% \begin{lstlisting}
% gapt> minimizeSolution(ehs)
% \end{lstlisting}
% Finally, the proof with cut is constructed:
% \begin{lstlisting}
% gapt> val fp = buildProofWithCut(ehs).get
% \end{lstlisting}
% In order to compare this with the initial proof, one can again count
% the number of rules:
% \begin{lstlisting}
% gapt> printProofStats(fp)
% ------------- Statistics ---------------
% Cuts: 1
% Number of quantifier rules: 7
% Number of rules: 25
% Quantifier complexity: 6
% ----------------------------------------
% \end{lstlisting}
% We showed how to run the cut-introduction algorithm step by step. There is,
% though, a command comprising all these steps:
% \begin{lstlisting}
% gapt> val fp2 = cutIntro.one_cut_one_quantifier( p )
% \end{lstlisting}
% Regarding the choice of the grammar, this command will compute the proofs with
% all minimal grammars and choose the smallest one (with respect to the number of rules).
% 
% The method \texttt{cutIntro.one\_cut\_many\_quantifiers} will proceed as above but will
% compute a single cut with a block of quantifiers. The method \texttt{cutIntro.many\_cuts\_one\_quantifier}
% uses a reduction to a MaxSAT problem and an external MaxSAT-solver for finding a
% minimal grammar corresponding to a proof with an arbitrary number of cuts with one quantifier each.

% \section{Miscellaneous}
%
% The method \texttt{printProofStats: LKProof $\rightarrow$ Unit}
% takes a proof and prints some statistics about it. It is helpful
% for getting a first impression of a proof; use it for example as:
%
% \begin{clilisting}
% gapt> printPoofStats( p )
% <console>:108: error: not found: value printPoofStats
%       printPoofStats( p )
%       ^
%
% \end{clilisting}

\vfill
\pagebreak
\begin{appendix}

\section{The Sequent Calculus}\label{app:sequent_calculus}

This section defines the rule systems used in GAPT. The rules can be constructed
via Scala-classes, which create the underlying data structure.

\subsection{LK}

\fxnote{update sequent calculus to new LK, describe higher-order LK directly here}

The rules of LK are listed below. Proof trees are constructed top-down, starting with axioms and with each rule introducing new inferences. With the exception of the definition rules, the constructors of the rules only allow inferences that are actually valid. Note that the rules are presented here as if they always act upon the outermost formulas in the upper sequent, but this is only for convenience of presentation. The basic constructors actually require the user to specify on which concrete formulas the inference should be performed.

Apart from those basic constructors, there is also a multitude of convenience constructors that facilitate easier proof construction. Moreover, there are so-called macro rules that reduce several inferences to a single command (e.g. introducing quantifier blocks). See the API documentation of the individual rules for details. 

\subsubsection*{Axioms}

\begin{multicols}{2}
\begin{prooftree}
\AxiomCm{}
\RightLabelm{(\mt{Logical axiom})}
\UnaryInfCm{A \seq A}
\end{prooftree}

\begin{prooftree}
\AxiomCm{}
\RightLabelm{\mt{$\top$ axiom}}
\UnaryInfCm{\seq \top}
\end{prooftree}

\begin{prooftree}
\AxiomCm{}
\RightLabelm{(\mt{Reflexivity axiom})}
\UnaryInfCm{\seq t = t}
\end{prooftree}

\begin{prooftree}
\AxiomCm{}
\RightLabelm{\mt{$\bot$ axiom}}
\UnaryInfCm{\bot \seq}
\end{prooftree}
\end{multicols}

\begin{prooftree}
\AxiomCm{}
\RightLabelm{\mt{Theory axiom}}
\UnaryInfCm{\Gamma \seq \Delta}
\end{prooftree}

Logical axioms and theory axioms may only contain atomic formulas.

\subsubsection*{Cut}

  \begin{prooftree}
  \AxiomCm{\Gamma \seq \Delta, A}
  \AxiomCm{A, \Sigma \seq \Pi}
  \RightLabelm{(\mt{cut})}
  \BinaryInfCm{\Gamma, \Sigma \seq \Delta, \Pi}
  \end{prooftree}

\subsubsection*{Structural rules}

\begin{multicols}{2}

  \subsubsection*{Left rules}
  
  \begin{prooftree}
  \AxiomCm{\Gamma \seq \Delta}
  \RightLabelm{(\mt{w:l})}
  \UnaryInfCm{A, \Gamma \seq \Delta}
  \end{prooftree}
  
  \begin{prooftree}
  \AxiomCm{A,A,\Gamma \seq \Delta}
  \RightLabelm{(\mt{c:l})}
  \UnaryInfCm{A,\Gamma\seq \Delta}
  \end{prooftree}
  
  \subsubsection*{Right rules}
  
  \begin{prooftree}
  \AxiomCm{\Gamma \seq \Delta}
  \RightLabelm{(\mt{w:r})}
  \UnaryInfCm{\Gamma \seq \Delta, A}
  \end{prooftree}
  
  \begin{prooftree}
  \AxiomCm{\Gamma \seq \Delta, A, A}
  \RightLabelm{(\mt{c:r})}
  \UnaryInfCm{\Gamma \seq \Delta, A}
  \end{prooftree}

\end{multicols}

\newpage

\subsubsection*{Propositional rules}

\begin{multicols}{2}

  \subsubsection*{Left rules}

  \begin{prooftree}
  \AxiomCm{A,B,\Gamma \seq \Delta}
  \RightLabelm{(\land\mt{:l})}
  \UnaryInfCm{A \land B,\Gamma \seq \Delta}
  \end{prooftree}
  
  \begin{prooftree}
  \AxiomCm{A, \Gamma \seq \Delta}
  \AxiomCm{B, \Sigma \seq \Pi}
  \RightLabelm{(\lor\mt{:l})}
  \BinaryInfCm{A \lor B, \Gamma, \Sigma \seq \Delta, \Pi}
  \end{prooftree}
  
  \begin{prooftree}
  \AxiomCm{\Gamma \seq \Delta, A}
  \RightLabelm{(\lnot\mt{:l})}
  \UnaryInfCm{\neg A, \Gamma \seq \Delta}
  \end{prooftree}
  
  \begin{prooftree}
  \AxiomCm{\Gamma \seq \Delta, A}
  \AxiomCm{B, \Sigma \seq \Pi}
  \RightLabelm{(\impl\mt{:l})}
  \BinaryInfCm{A \impl B, \Gamma, \Sigma \seq \Delta, \Pi}
  \end{prooftree}

  \subsubsection*{Right rules}

  \begin{prooftree}
  \AxiomCm{\Gamma \seq \Delta, A}
  \AxiomCm{\Sigma \seq \Pi, B}
  \RightLabelm{(\land\mt{:r})}
  \BinaryInfCm{\Gamma, \Sigma \seq \Delta, \Pi, A \land B}
  \end{prooftree}
  
  \begin{prooftree}
  \AxiomCm{\Gamma \seq \Delta, A, B}
  \RightLabelm{(\lor\mt{:r})}
  \UnaryInfCm{\Gamma \seq \Delta, A \lor B}
  \end{prooftree}
  
  \begin{prooftree}
  \AxiomCm{A, \Gamma\seq \Delta}
  \RightLabelm{(\lnot\mt{:r})}
  \UnaryInfCm{\Gamma \seq \Delta, \neg A}
  \end{prooftree}
  
  \begin{prooftree}
  \AxiomCm{A, \Gamma \seq \Delta, B}
  \RightLabelm{(\impl\mt{:r})}
  \UnaryInfCm{\Gamma \seq \Delta, A \impl B}
  \end{prooftree}

\end{multicols}

\subsubsection*{Quantifier rules}

\begin{multicols}{2}

  \subsubsection*{Left rules}

  \begin{prooftree}
  \AxiomCm{A[t/x], \Gamma \seq \Delta}
  \RightLabelm{(\forall\mt{:l})}
  \UnaryInfCm{\forall x A, \Gamma \seq \Delta}
  \end{prooftree}
  
  \begin{prooftree}
  \AxiomCm{ A[y/x], \Gamma \seq \Delta}
  \RightLabelm{(\exists\mt{:l})}
  \UnaryInfCm{\exists x A, \Gamma \seq \Delta}
  \end{prooftree}
  
  \subsubsection*{Right rules}
  
  \begin{prooftree}
  \AxiomCm{\Gamma \seq \Delta, A[y/x]}
  \RightLabelm{(\forall\mt{:r})}
  \UnaryInfCm{\Gamma \seq \Delta, \forall x A}
  \end{prooftree}
  
  \begin{prooftree}
  \AxiomCm{\Gamma \seq \Delta, A[t/x]}
  \RightLabelm{(\exists\mt{:r})}
  \UnaryInfCm{\Gamma \seq \Delta, \exists x A}
  \end{prooftree}

\end{multicols}

The variable $y$ must not occur free in $\Gamma$, $\Delta$ or $A$. The term $t$ must avoid variable capture, i.e. it must not contain free occurrences of variables bound in $A$.

\subsubsection*{Equality rules}

\begin{multicols}{2}

  \subsubsection*{Left rules}

  \begin{prooftree}
  \AxiomCm{s = t, A[T/s], \Sigma \seq \Pi}
  \RightLabelm{(\mt{=:l})}
  \UnaryInfCm{s = t, A[T/t], \Sigma \seq \Pi}
  \end{prooftree}
  
  \begin{prooftree}
  \AxiomCm{s = t, A[T/t], \Sigma \seq \Pi}
  \RightLabelm{(\mt{=:l})}
  \UnaryInfCm{s = t, A[T/s], \Sigma \seq \Pi}
  \end{prooftree}
  
  \subsubsection*{Right rules}
  
  \begin{prooftree}
  \AxiomCm{s = t, \Sigma \seq \Pi, A[T/s]}
  \RightLabelm{(\mt{=:r})}
  \UnaryInfCm{s = t, \Sigma \seq \Pi, A[T/t]}
  \end{prooftree}
  
  \begin{prooftree}
  \AxiomCm{s = t, \Sigma \seq \Pi, A[T/t]}
  \RightLabelm{(\mt{=:r})}
  \UnaryInfCm{s = t, \Sigma \seq \Pi, A[T/s]}
  \end{prooftree}
  
\end{multicols}
Each equation rule replaces exactly one occurrence of a term in its auxiliary formula.

\subsubsection*{Definition rules}
\begin{center}
 \AxiomCm{A, \Gamma \seq \Delta}
 \RightLabelm{(\mt{def:l})}
 \UnaryInfCm{B, \Gamma \seq \Delta}
 \DisplayProof
 \AxiomCm{\Gamma \seq \Delta, A}
 \RightLabelm{(\mt{def:r})}
 \UnaryInfCm{\Gamma \seq \Delta, B}
 \DisplayProof
\end{center}
These definition rules are extremely liberal, as they allow the replacement of any formula by any other formula.

\subsubsection*{Induction}
  The induction rule applies to arbitrary algebraic datatypes. Let $c_1,...,c_n$ be the constructors of a type and let $k_i$ be the arity of $c_i$. Let $F[x]$ be a formula with $x$ a free variable of the appropriate type. Then we call the sequent $\mathcal{S}_i := F[x_1],...,F[x_{k_i}], \Gamma_i \seq \Delta_i, F[c_i(x_1,...,x_{k_i})]$ the $i$-th induction step. In this case, the induction rule has the form
  \begin{prooftree}
    \AxiomCm{(\pi_1)}
    \noLine
    \UnaryInfCm{\mathcal{S}_1}
    \AxiomCm{(\pi_2)}
    \noLine
    \UnaryInfCm{\mathcal{S}_2}
    \AxiomCm{\dots}
    \AxiomCm{(\pi_n)}
    \noLine
    \UnaryInfCm{\mathcal{S}_n}
    \RightLabelm{(\mt{ind})}
    \QuaternaryInfC{$\Gamma \seq \Delta, \forall x F[x]$}
  \end{prooftree}
  
  In the case of the natural numbers, there are two constructors: $0$ of arity 0 and $s$ of arity 1. Consequently, the induction rule reduces to
  
  \begin{prooftree}
    \AxiomCm{(\pi_1)}
    \noLine
    \UnaryInfCm{\Gamma_1 \seq \Delta_1, F[0]}
    \AxiomCm{(\pi_2)}
    \noLine
    \UnaryInfCm{F[x], \Gamma_2 \seq \Delta_2, F[sx]}
    \RightLabelm{(\mt{ind})}
    \BinaryInfCm{\Gamma_1, \Gamma_2 \seq \Delta_1, \Delta_2, \forall x F[x]}
  \end{prooftree}



\subsection{LKsk}
  
\begin{meta}
 TODO: give brief description of LKsk
\end{meta}

LKsk operates on labelled formulas. A label $\ell$ is a finite list of terms, a labelled formula is a pair $(F, \ell)$, written as $\sklabel{F}{\ell}$. If $\ell$ is a label and $t$ a term, we write $\ell;t$ for the concatenation of $\ell$ and $t$.

\subsubsection*{Axioms}

\begin{multicols}{2}
\begin{prooftree}
\AxiomCm{}
\RightLabelm{(\mt{Logical axiom})}
\UnaryInfCm{\sklabel{A}{\ell_1} \seq \sklabel{A}{\ell_2}}
\end{prooftree}

\begin{prooftree}
\AxiomCm{}
\RightLabelm{\mt{$\top$ axiom}}
\UnaryInfCm{\seq \sklabel{\top}{\ell}}
\end{prooftree}

\begin{prooftree}
\AxiomCm{}
\RightLabelm{(\mt{Reflexivity axiom})}
\UnaryInfCm{\seq \sklabel{t = t}{\ell}}
\end{prooftree}

\begin{prooftree}
\AxiomCm{}
\RightLabelm{\mt{$\bot$ axiom}}
\UnaryInfCm{\sklabel{\bot}{\ell}\seq}
\end{prooftree}
\end{multicols}

\begin{prooftree}
\AxiomCm{}
\RightLabelm{\mt{Theory axiom}}
\UnaryInfCm{\sklabel{A_1}{\ell_1},...,\sklabel{A_m}{\ell_m} \seq \sklabel{B_1}{\ell'_1},...,\sklabel{B_n}{\ell'_n}}
\end{prooftree}

Logical axioms and theory axioms may only contain atomic formulas.

\subsubsection*{Cut}

  \begin{prooftree}
  \AxiomCm{\Gamma \seq \Delta, \sklabel{A}{\ell_1}}
  \AxiomCm{\sklabel{A}{\ell_2}, \Sigma \seq \Pi}
  \RightLabelm{(\mt{cut})}
  \BinaryInfCm{\Gamma, \Sigma \seq \Delta, \Pi}
  \end{prooftree}
  
  Note that the labels of the cut formulas do not need to be equal.

\subsubsection*{Structural rules}

\begin{multicols}{2}

  \subsubsection*{Left rules}
  
  \begin{prooftree}
  \AxiomCm{\Gamma \seq \Delta}
  \RightLabelm{(\mt{w:l})}
  \UnaryInfCm{\sklabel{A}{\ell}, \Gamma \seq \Delta}
  \end{prooftree}
  
  \begin{prooftree}
  \AxiomCm{\sklabel{A}{\ell},\sklabel{A}{\ell},\Gamma \seq \Delta}
  \RightLabelm{(\mt{c:l})}
  \UnaryInfCm{\sklabel{A}{\ell},\Gamma\seq \Delta}
  \end{prooftree}
  
  \subsubsection*{Right rules}
  
  \begin{prooftree}
  \AxiomCm{\Gamma \seq \Delta}
  \RightLabelm{(\mt{w:r})}
  \UnaryInfCm{\Gamma \seq \Delta, \sklabel{A}{\ell}}
  \end{prooftree}
  
  \begin{prooftree}
  \AxiomCm{\Gamma \seq \Delta, \sklabel{A}{\ell}, \sklabel{A}{\ell}}
  \RightLabelm{(\mt{c:r})}
  \UnaryInfCm{\Gamma \seq \Delta, \sklabel{A}{\ell}}
  \end{prooftree}

\end{multicols}

\subsubsection*{Propositional rules}

\begin{multicols}{2}

  \subsubsection*{Left rules}

  \begin{prooftree}
  \AxiomCm{\sklabel{A}{\ell},\sklabel{B}{\ell},\Gamma \seq \Delta}
  \RightLabelm{(\land\mt{:l})}
  \UnaryInfCm{\sklabel{A \land B}{\ell},\Gamma \seq \Delta}
  \end{prooftree}
  
  \begin{prooftree}
  \AxiomCm{\sklabel{A}{\ell}, \Gamma \seq \Delta}
  \AxiomCm{\sklabel{B}{\ell}, \Sigma \seq \Pi}
  \RightLabelm{(\lor\mt{:l})}
  \BinaryInfCm{\sklabel{A \lor B}{\ell}, \Gamma, \Sigma \seq \Delta, \Pi}
  \end{prooftree}
  
  \begin{prooftree}
  \AxiomCm{\Gamma \seq \Delta, \sklabel{A}{\ell}}
  \RightLabelm{(\lnot\mt{:l})}
  \UnaryInfCm{\sklabel{\neg A}{\ell}, \Gamma \seq \Delta}
  \end{prooftree}
  
  \begin{prooftree}
  \AxiomCm{\Gamma \seq \Delta, \sklabel{A}{\ell}}
  \AxiomCm{\sklabel{B}{\ell}, \Sigma \seq \Pi}
  \RightLabelm{(\impl\mt{:l})}
  \BinaryInfCm{\sklabel{A \impl B}{\ell}, \Gamma, \Sigma \seq \Delta, \Pi}
  \end{prooftree}

  \subsubsection*{Right rules}

  \begin{prooftree}
  \AxiomCm{\Gamma \seq \Delta, \sklabel{A}{\ell}}
  \AxiomCm{\Sigma \seq \Pi, \sklabel{B}{\ell}}
  \RightLabelm{(\land\mt{:r})}
  \BinaryInfCm{\Gamma, \Sigma \seq \Delta, \Pi, \sklabel{A \land B}{\ell}}
  \end{prooftree}
  
  \begin{prooftree}
  \AxiomCm{\Gamma \seq \Delta, \sklabel{A}{\ell}, \sklabel{B}{\ell}}
  \RightLabelm{(\lor\mt{:r})}
  \UnaryInfCm{\Gamma \seq \Delta, \sklabel{A \lor B}{\ell}}
  \end{prooftree}
  
  \begin{prooftree}
  \AxiomCm{\sklabel{A}{\ell}, \Gamma\seq \Delta}
  \RightLabelm{(\lnot\mt{:r})}
  \UnaryInfCm{\Gamma \seq \Delta, \sklabel{\neg A}{\ell}}
  \end{prooftree}
  
  \begin{prooftree}
  \AxiomCm{\sklabel{A}{\ell}, \Gamma \seq \Delta, \sklabel{B}{\ell}}
  \RightLabelm{(\impl\mt{:r})}
  \UnaryInfCm{\Gamma \seq \Delta, \sklabel{A \impl B}{\ell}}
  \end{prooftree}

\end{multicols}

\subsubsection*{Quantifier rules}

\begin{multicols}{2}

  \subsubsection*{Left rules}
  
   \begin{prooftree}
  \AxiomCm{\sklabel{A[t/x]}{\ell;t}, \Gamma \seq \Delta}
  \RightLabelm{(\forall\mt{:l})}
  \UnaryInfCm{\sklabel{\forall x A}{\ell}, \Gamma \seq \Delta}
  \end{prooftree}
  
  \begin{prooftree}
  \AxiomCm{ \sklabel{A[y/x]}{\ell}, \Gamma \seq \Delta}
  \RightLabelm{(\exists\mt{:l})}
  \UnaryInfCm{\sklabel{\exists x A}{\ell}, \Gamma \seq \Delta}
  \end{prooftree}
  
  \begin{prooftree}
  \AxiomCm{ \sklabel{A[f(\ell)/x]}{\ell}, \Gamma \seq \Delta}
  \RightLabelm{(\exists^{sk}\mt{:l})}
  \UnaryInfCm{\sklabel{\exists x A}{\ell}, \Gamma \seq \Delta}
  \end{prooftree}
  
  \subsubsection*{Right rules}
  
  \begin{prooftree}
  \AxiomCm{\Gamma \seq \Delta, \sklabel{A[y/x]}{\ell}}
  \RightLabelm{(\forall\mt{:r})}
  \UnaryInfCm{\Gamma \seq \Delta, \sklabel{\forall x A}{\ell}}
  \end{prooftree}
  
  \begin{prooftree}
  \AxiomCm{\Gamma \seq \Delta, \sklabel{A[f(\ell)/x]}{\ell}}
  \RightLabelm{(\forall^{sk}\mt{:r})}
  \UnaryInfCm{\Gamma \seq \Delta, \sklabel{\forall x A}{\ell}}
  \end{prooftree}
  
  \begin{prooftree}
  \AxiomCm{\Gamma \seq \Delta, \sklabel{A[t/x]}{\ell;t}}
  \RightLabelm{(\exists\mt{:r})}
  \UnaryInfCm{\Gamma \seq \Delta, \sklabel{\exists x A}{\ell}}
  \end{prooftree}

\end{multicols}

The variable $y$ must not occur free in $\Gamma$, $\Delta$ or $A$. The term $t$ must avoid variable capture, i.e. it must not contain free occurrences of variables bound in $A$.

\subsubsection*{Equality rules}

\begin{multicols}{2}

  \subsubsection*{Left rules}

  \begin{prooftree}
  \AxiomCm{\sklabel{s = t}{\ell_1}, \sklabel{A[T/s]}{\ell_2}, \Sigma \seq \Pi}
  \RightLabelm{(\mt{=:l})}
  \UnaryInfCm{\sklabel{s = t}{\ell_1}, \sklabel{A[T/t]}{\ell_2}, \Sigma \seq \Pi}
  \end{prooftree}
  
  \begin{prooftree}
  \AxiomCm{\sklabel{s = t}{\ell_1}, \sklabel{A[T/t]}{\ell_2}, \Sigma \seq \Pi}
  \RightLabelm{(\mt{=:l})}
  \UnaryInfCm{\sklabel{s = t}{\ell_1}, \sklabel{A[T/s]}{\ell_2}, \Sigma \seq \Pi}
  \end{prooftree}
  
  \subsubsection*{Right rules}
  
  \begin{prooftree}
  \AxiomCm{\sklabel{s = t}{\ell_1}, \Sigma \seq \Pi, \sklabel{A[T/s]}{\ell_2}}
  \RightLabelm{(\mt{=:r})}
  \UnaryInfCm{\sklabel{s = t}{\ell_1}, \Sigma \seq \Pi, \sklabel{A[T/t]}{\ell_2}}
  \end{prooftree}
  
  \begin{prooftree}
  \AxiomCm{\sklabel{s = t}{\ell_1}, \Sigma \seq \Pi, \sklabel{A[T/t]}{\ell_2}}
  \RightLabelm{(\mt{=:r})}
  \UnaryInfCm{\sklabel{s = t}{\ell_1}, \Sigma \seq \Pi,\sklabel{A[T/s]}{\ell_2}}
  \end{prooftree}
  
\end{multicols}
Each equation rule replaces exactly one occurrence of a term in its auxiliary formula.

\section{The Resolution Calculus}

\subsection*{Initial clauses}

\begin{prooftree}
\AxiomC{}\RightLabel{InputClause}
\UnaryInfC{$C$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}\RightLabel{ReflexivityClause}
\UnaryInfC{$t=t$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}\RightLabel{TautologyClause}
\UnaryInfC{$a \lor \neg a$}
\end{prooftree}

\subsection*{Structural rules}

\begin{prooftree}
\AxiomC{$a \lor a \lor C$}\RightLabel{Factor}
\UnaryInfC{$a \lor C$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$C$}\RightLabel{Instance}
\UnaryInfC{$C \sigma$}
\end{prooftree}

\subsection*{Logical rules}

\begin{prooftree}
\AxiomC{$C \lor a$}
\AxiomC{$\neg a \lor D$}
\RightLabel{Resolution}
\BinaryInfC{$C \lor D$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$C \lor t=s$}
\AxiomC{$l[t] \lor D$}
\RightLabel{Paramodulation}
\BinaryInfC{$C \lor l[s] \lor D$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$C \lor t=s$}
\AxiomC{$l[s] \lor D$}
\RightLabel{Paramodulation}
\BinaryInfC{$C \lor l[t] \lor D$}
\end{prooftree}

\subsection{Ral}

Ral operates on sequents of labelled formulas, just as LKsk.  A label $\ell$ is
a finite set of terms, a labelled formula is a pair $(F, \ell)$, written as
$\sklabel{F}{\ell}$. If $\ell$ is a label and $t$ a term, we write $\ell;t$ for
the concatenation of $\ell$ and $t$.

\begin{prooftree}
  \AxiomCm{}
  \RightLabel{RalInitial}
  \UnaryInfCm{\Gamma \vdash \Delta}
\end{prooftree}

The substitution also substitutes the variables in the labels:
\begin{prooftree}
  \AxiomCm{\Gamma \vdash \Delta}
  \RightLabel{RalSub}
  \UnaryInfCm{\Gamma\sigma \vdash \Delta\sigma}
\end{prooftree}

The resolution rule does not require the labels to be equal:
\begin{prooftree}
  \AxiomCm{\Gamma \vdash \Delta, \sklabel{A}{\ell_1}, \dots, \sklabel{A}{\ell_m}}
  \AxiomCm{\sklabel{A}{\ell_1}, \dots, \sklabel{A}{\ell_n}, \Sigma \vdash \Pi}
  \RightLabel{RalCut}
  \BinaryInfCm{\Gamma, \Sigma \vdash \Delta, \Pi}
\end{prooftree}

Factoring is restricted to atoms:
\begin{multicols}{2}
\begin{prooftree}
  \AxiomCm{\sklabel{a}{\ell_1}{a},\sklabel{a}{\ell_2},\Gamma \vdash \Delta}
  \RightLabel{RalFactor}
  \UnaryInfCm{\sklabel{a}{\ell_1}, \Gamma \vdash \Delta}
\end{prooftree}
\begin{prooftree}
  \AxiomCm{\Gamma \vdash \Delta, \sklabel{a}{\ell_1},\sklabel{a}{\ell_2}}
  \RightLabel{RalFactor}
  \UnaryInfCm{\Gamma \vdash \Delta, \sklabel{a}{\ell_1}}
\end{prooftree}
\end{multicols}

Paramodulation can rewrite the equation in both directions, in a formula of the
antecedent or the succedent---this is one of the four possibilities:
\begin{prooftree}
  \AxiomCm{\Gamma \vdash \Delta, \sklabel{t=s}{\ell}}
  \AxiomCm{\Sigma \vdash \Pi, \sklabel{A[t]}{\ell}}
  \RightLabel{RalPara}
  \BinaryInfCm{\Gamma, \Sigma \vdash \Delta, \sklabel{A[s]}{\ell}}
\end{prooftree}

\begin{multicols}{2}
\begin{prooftree}
  \AxiomCm{\sklabel{\forall x\: A[x]}{\ell}, \Gamma \vdash \Delta}
  \RightLabel{RalAllF}
  \UnaryInfCm{\sklabel{A[s\ell]}{\ell}, \Gamma \vdash \Delta}
\end{prooftree}
\begin{prooftree}
  \AxiomCm{\Gamma \vdash \Delta, \sklabel{\forall x\: A[x]}{\ell}}
  \RightLabel{RalAllT}
  \UnaryInfCm{\Gamma \vdash \Delta, \sklabel{A[\alpha]}{\ell;\alpha}}
\end{prooftree}
\end{multicols}

\begin{multicols}{2}
\begin{prooftree}
  \AxiomCm{\sklabel{\exists x\: A[x]}{\ell}, \Gamma \vdash \Delta}
  \RightLabel{RalExF}
  \UnaryInfCm{\sklabel{A[\alpha]}{\ell;\alpha}, \Gamma \vdash \Delta}
\end{prooftree}
\begin{prooftree}
  \AxiomCm{\Gamma \vdash \Delta, \sklabel{\exists x\: A[x]}{\ell}}
  \RightLabel{RalExT}
  \UnaryInfCm{\Gamma \vdash \Delta, \sklabel{A[s\ell]}{\ell}}
\end{prooftree}
\end{multicols}

\begin{multicols}{2}
\begin{prooftree}
  \AxiomCm{\sklabel{\top}{\ell}, \Gamma \vdash \Delta}
  \RightLabel{RalTopF}
  \UnaryInfCm{\Gamma \vdash \Delta}
\end{prooftree}
\begin{prooftree}
  \AxiomCm{\Gamma \vdash \Delta, \sklabel{\bot}{\ell}}
  \RightLabel{RalBottomT}
  \UnaryInfCm{\Gamma \vdash \Delta}
\end{prooftree}
\end{multicols}

\begin{multicols}{2}
\begin{prooftree}
  \AxiomCm{\sklabel{\neg A}{\ell}, \Gamma \vdash \Delta}
  \RightLabel{RalNegF}
  \UnaryInfCm{\Gamma \vdash \Delta, \sklabel{A}{\ell}}
\end{prooftree}
\begin{prooftree}
  \AxiomCm{\Gamma \vdash \Delta, \sklabel{\neg A}{\ell}}
  \RightLabel{RalNegT}
  \UnaryInfCm{\sklabel{A}{\ell}, \Gamma \vdash \Delta}
\end{prooftree}
\end{multicols}

\begin{multicols}{3}
\begin{prooftree}
  \AxiomCm{\sklabel{A \land B}{\ell}, \Gamma \vdash \Delta}
  \RightLabel{RalAndF}
  \UnaryInfCm{\sklabel{A}{\ell}, \sklabel{B}{\ell}, \Gamma \vdash \Delta}
\end{prooftree}
\begin{prooftree}
  \AxiomCm{\Gamma \vdash \Delta, \sklabel{A \land B}{\ell}}
  \RightLabel{RalAndT1}
  \UnaryInfCm{\Gamma \vdash \Delta, \sklabel{A}{\ell}}
\end{prooftree}
\begin{prooftree}
  \AxiomCm{\Gamma \vdash \Delta, \sklabel{A \land B}{\ell}}
  \RightLabel{RalAndT2}
  \UnaryInfCm{\Gamma \vdash \Delta, \sklabel{B}{\ell}}
\end{prooftree}
\end{multicols}

\begin{multicols}{3}
\begin{prooftree}
  \AxiomCm{\sklabel{A \lor B}{\ell}, \Gamma \vdash \Delta}
  \RightLabel{RalOrF1}
  \UnaryInfCm{\sklabel{A}{\ell}, \Gamma \vdash \Delta}
\end{prooftree}
\begin{prooftree}
  \AxiomCm{\sklabel{A \lor B}{\ell}, \Gamma \vdash \Delta}
  \RightLabel{RalOrF2}
  \UnaryInfCm{\sklabel{B}{\ell}, \Gamma \vdash \Delta}
\end{prooftree}
\begin{prooftree}
  \AxiomCm{\Gamma \vdash \Delta, \sklabel{A \lor B}{\ell}}
  \RightLabel{RalOrT}
  \UnaryInfCm{\Gamma \vdash \Delta, \sklabel{A}{\ell}, \sklabel{B}{\ell}}
\end{prooftree}
\end{multicols}

\begin{multicols}{3}
\begin{prooftree}
  \AxiomCm{\sklabel{A \impl B}{\ell}, \Gamma \vdash \Delta}
  \RightLabel{RalImpF1}
  \UnaryInfCm{\Gamma \vdash \Delta, \sklabel{A}{\ell}}
\end{prooftree}
\begin{prooftree}
  \AxiomCm{\sklabel{A \impl B}{\ell}, \Gamma \vdash \Delta}
  \RightLabel{RalImpF2}
  \UnaryInfCm{\sklabel{B}{\ell}, \Gamma \vdash \Delta}
\end{prooftree}
\begin{prooftree}
  \AxiomCm{\Gamma \vdash \Delta, \sklabel{A \impl B}{\ell}}
  \RightLabel{RalImpT}
  \UnaryInfCm{\sklabel{A}{\ell}, \Gamma \vdash \Delta, \sklabel{B}{\ell}}
\end{prooftree}
\end{multicols}

% \section{Command Reference}
% 
% \begin{meta}
% Shall we really keep a command reference in the user manual? This may make more sense
% as \texttt{help <command>} in the CLI.
% \end{meta}
% 
% \paragraph{\textbf{prover9: List[Sequent],Seq[Clause] $\rightarrow$ Option[ResolutionProof[Clause]]}}
% sends the input clause set (given as either List[Sequent] or Seq[Clause]) to prover9. Returns
% the resolution proof obtained from replaying the output proof of prover9,
% see~\cite{Dunchev12System} for details.
% 
% \paragraph{\textbf{miniSATsolve: HOLFormula $\rightarrow$ Option[Interpretation]}}
% Searches a model for a quantifier-free formula using the MiniSAT SAT Solver.
% Returns None if unsatisfiable, and Some(Interpretation) otherwise.
% 
% \paragraph{\textbf{MiniSAT.isValid: HOLFormula $\rightarrow$ Boolean}}
% Checks if a quantifier-free formula is valid using the MiniSAT SAT Solver.
% 
% \paragraph{\textbf{lkTolksk: LKProof $\rightarrow$ LKProof}}
% This method takes a proof in classical logic (LK), such as one generated by HLK and 
% loaded by the method \texttt{XMLProofDatabaseParser}, and transforms it to a proof on the
% calculus $\mathbf{LK}_{sk}$. This calculus was proposed to solve the problem of
% Skolemization in higher-order logic, and it basically replaces eigenvariables
% with Skolem terms. For more information, see \cite{Hetzl11CERES}.
% 
% \paragraph{\textbf{cutIntro: LKProof $\rightarrow$ LKProof}}
% This method is the implementation of the cut-introduction algorithm described on
% \cite{Hetzl2012}. It takes a cut-free proof in classical logic, automatically
% computes a universally quantified cut formula and builds a new proof with this
% cut.
% 
% \paragraph{\textbf{termsExtraction: LKProof $\rightarrow$ Map[FormulaOccurrence, List[List[FOLTerm]]]}}
% A crucial part of the cut-introduction algorithm of \cite{Hetzl2012} is the
% computation of the term set, which are the witnesses of the existential
% quantifiers of the end-sequent of a proof. This method takes a proof and returns
% a map. This map associates each existentially quantified formula of the end
% sequent with a list of tuples of terms. These tuples will have the same size as
% the number of quantifiers of the formula.
% 
% \paragraph{\textbf{regularize: LKProof $\rightarrow$ LKProof}}
% {\color{red}TODO}
% 
% \paragraph{\textbf{createHOLExpression: String $\rightarrow$ HOLExpression
% (Forall x1: (i -> (i -> i)) a(x1: (i -> (i -> i)), x2: i, c1: (i -> i)))}}
% {\color{red}TODO}
% 
% \paragraph{\textbf{deleteTautologies: List[FSequent] $\rightarrow$ List[FSequent]}}
% {\color{red}TODO}
% 
% \paragraph{\textbf{removeDuplicates: List[FSequent] $\rightarrow$ List[FSequent]}}
% {\color{red}TODO}
% 
% \paragraph{\textbf{simpleUnitResolutionNormalization: List[FSequent] $\rightarrow$ List[FSequent]}}
% {\color{red}TODO}
% 
% \paragraph{\textbf{subsumedClausesRemoval: List[FSequent] $\rightarrow$ List[FSequent]}}
% {\color{red}TODO}
% 
% \paragraph{\textbf{normalizeClauses: List[FSequent] $\rightarrow$ List[FSequent]}}
% {\color{red}TODO}
% 
% \paragraph{\textbf{writeLatex: List[FSequent], String $\rightarrow$ Unit}}
% {\color{red}TODO}
% 
% \paragraph{\textbf{writeLabelledSequentListLatex: List[LabelledSequent], String $\rightarrow$ Unit}}
% {\color{red}TODO}
% 
% \paragraph{\textbf{extractStruct: LKProof $\rightarrow$ Struct}}
% Extracts a struct from a LKProof. A struct is referred to as a clause term in
% \cite{Baaz2011}. I will give a quick definition of it. For more details and
% for an explanation of this structure on the CERES method, please refer to
% \cite{Baaz2011}, Chapter 6.
% 
% Given a proof with cuts, by removing all the inference rules that operate on end
% sequent ancestors, we obtain a proof of the empty sequent (refutation). The
% axioms of this refutation are represented by \textit{clause terms}. Clause
% terms are $\{\oplus, \otimes\}$-terms over clause sets, and it's interpretation
% is the following:
% 
% \begin{align*}
%   |\mathcal{C}| &= \mathcal{C} \text{ if $\mathcal{C}$ is a set of clauses.}\\
%    |X \oplus Y| &= |X| \cup |Y|\\
%   |X \otimes Y| &= |X| \times |Y|
% \end{align*}
% 
% where $\mathcal{C} \times \mathcal{D} = \{ C \circ D | C \in \mathcal{C} \wedge
% D \in \mathcal{D}\}$ and if $S = \Gamma \vdash \Delta$ and $S' = \Pi \vdash
% \Lambda$, $S \circ S' = \Gamma, \Pi \vdash \Delta, \Lambda.$
% 
% \paragraph{\textbf{StandardClauseSet.transformStructToClauseSet: Struct $\rightarrow$ List[Sequent]}} computes
% the standard characteristic clause set
% from the struct, see~\cite[Section 4.2.1]{WoltzenlogelPaleo09General} for details.
% 
% \paragraph{\textbf{structToLabelledClausesList: Struct $\rightarrow$ List[LabelledSequent]}}
% {\color{red}TODO}
% 

% do we still need this section?
% \section{Running the system}
% 
% If you used svn to check out the source of GAPT from the website, after
% everything is downloaded you should see two folders: ``doc'' and ``source''. To
% compile the system, just go into the folder ``source'' and type:
% 
% \begin{lstlisting}[mathescape=false]
% $ mvn install
% \end{lstlisting}
% 
% Then you can go get something to eat, a coffee or anything more interesting. The
% whole system takes about 15 minutes (or more) to compile, and you don't want to keep
% staring at a screen printing non sense for that long. It's good to check,
% though, once in a while, if no errors occurred. If something wrong happened,
% there are somethings you can do (in that order):
% 
% \begin{enumerate}
% \item Make sure you have all required packages (Section \ref{sec:sysreq}).
% \item Try running \texttt{make clean} and then \texttt{make install} again.
% \item Send us an e-mail ({\color{red}TODO}: which e-mail?).
% \end{enumerate}
% 
% Probably the first thing you want to do after compiling your project is run it
% and make some tests. The easiest way to do this, is to run the scripts in the
% source folder. There are two bash scripts in this folder that you should care
% about. You may first want to make them executable:
% 
% \begin{lstlisting}[mathescape=false]
% $ chmod +x cli.sh
% $ chmod +x gui.sh
% \end{lstlisting}
% 
% What do each of these scripts do?
% 
% \texttt{cli.sh}: This will start GAPT inside a scala iteractive shell.
% 
% \texttt{gui.sh}: This will start ProofTool, an interface to visualize proofs.
% 
% If for any reason these scripts do not work, no need for crying.
% The jars for these applications are created during compilation
% and it's just a matter of finding the directory where they are to execute them.
% 
% The jar for GAPT is created inside the directory \texttt{cli/target} (you
% should use the one with dependencies) and you can execute it like this:
% 
% \begin{lstlisting}[mathescape=false]
% $ java -jar cli-XX-SNAPSHOT-jar-with-dependencies.jar
% \end{lstlisting}
% 
% The jar for ProofTool is created inside the directory
% \texttt{gui/prooftool/target} (also use the one with dependencies) and again you
% can execute it like this:
% 
% \begin{lstlisting}[mathescape=false]
% $ java -jar prooftool-XX-SNAPSHOT-jar-with-dependencies.jar
% \end{lstlisting}

\section{Formula Syntax}
\label{app:formulasyntax}
\subsection{Prover 9 parser (parseFormula)}

The Prover9 parser interpretes names strings built over the alphabet
 $[\mathtt{a, \ldots, z, A ,\ldots, Z, 0, \ldots 9} ]$. Also the
 equality symbol $=$ and the arithmetic operators $\{\mathtt{+,-,*,/}\}$
 are names.

Since prover 9 has two naming schemes, we describe both of them. The default
 is the native LADR scheme.

\subsubsection{LADR naming scheme (default)}

Names starting with lower case letters from \texttt{u} to \texttt{z} are
 interpeted as variable symbols. Every name starting with a different letter
 is interpeted as a constant/function/predicate symbol, depending on the
 position in the term.

\subsubsection{Prolog naming scheme}
Names starting with upper case letters from \texttt{A} to \texttt{Z} are
 interpeted as variable symbols. Every name starting with a different letter
 is interpeted as a constant/function, depending on the
 position in the term. Predicates start with a lower or an upper case letter.

\subsubsection{Terms and Formulas}
Arguments are always seperated by commas and put in parenthesis. Terms are
 built from variable, constant symbols and function symbols applied
 to a number of arguments, which are terms. Likewise, atoms are
 predicate symbols, possibly with arguments which are again terms. The
 function symbols $\{\mathtt{+,-,*,/}\}$ and the equality predicate $=$
 are written in infix notation.

For example, the following are terms in the LADR naming scheme:

 \begin{lstlisting}
   "constant", "variable", "function(constant,variable)", "s_{21} + 5"
 \end{lstlisting}

And the following are atoms:

 \begin{lstlisting}
   "P1(alpha, beta(x))", "25 = v"
 \end{lstlisting}

The logical connectives are called $\{\mathtt{\&,|,->,all,exists}\}$ where
 the quantifiers and negation are written in prefix form and conjunction,
 disjunction and implication are written in infix form.

Conjunction and disjunction are right-associative. Quantifiers always need to
 be enclosed in parenthesis but a series of quantfiers doesn't need parenthesis
 in between. The binding order is (from strongest to weakest):
 $\mathtt{\neg,\forall,\exists,\land\lor,\rightarrow}$.


For example, the formula $\forall x (P(x,f(x)) \rightarrow \exists y P(x,y))$
 is parsed as:

\begin{clilisting}
gapt> parseFormula("(all x (P(x,f(x)) -> (exists y P(x,y))))")
res21: at.logic.gapt.expr.FOLFormula = ∀x.(P(x,f(x))⊃∃y.P(x,y))

\end{clilisting}

The Prolog scheme can be parsed as well using the \texttt{Prover9TermParser}
class:

\begin{clilisting}
gapt> Prover9TermParser.parseFormula("(all X (P(X,f(X)) -> (exists Y P(X,Y))))")
res22: at.logic.gapt.expr.FOLFormula = ∀X.(P(X,f(X))⊃∃Y.P(X,Y))

\end{clilisting}




\end{appendix}

\vfill
\pagebreak

\bibliographystyle{plain}
\bibliography{references}
\end{document}
