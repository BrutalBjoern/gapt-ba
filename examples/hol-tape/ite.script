// A scala script which generates hard problems for higher order theorem provers.
// Formulas:
//   f1,f2 ... if-then-else axiomatizations
//   f3,f4 ... properties of the successor function (0 is no successor and a number is always different from its successor)
//   sc    ... there exists a function h s.t. h(0) = 1, h(1) = 0, h(2) = 0
//   sc2   ... there exists a function h s.t. h(0) = 1, h(1) = 0, h(2) = 1
//   w1    ... witness for sc
//   w2    ... witness for sc2


val decl = "var X:o; var U,V:i; const ite : o > (i > (i>i)); var x,y:i; const zero:i; const s:i>i; var H:i>i; const h:i>i; "
val s1 = "(all X all U all V (X -> ite(X,U,V) = U))"
val s2 = "(all X all U all V (-X -> ite(X,U,V) = V))"
val s3 = "(all x -(s(x) = zero))"
val s4 = "(all x -(s(x) = x))"
val s5 = "(all x (h(x) = ite((x=zero), s(zero), zero) ))"
val s6 = "(all x (h(x) = ite((x=s(zero)), zero, s(zero)) ))"

val sc = "(exists H (H(zero)=s(zero) & H(s(zero))=zero & H(s(s(zero))) = zero))"
val sc2 = "(exists H (H(zero)=s(zero) & H(s(zero))=zero & H(s(s(zero))) = s(zero)))"

val List(f1,f2,f3,f4,w1,w2,conclusion,conclusion2) = List(s1,s2,s3,s4,s5,s6,sc,sc2).map(str => parseLLKFormula(decl+str))

val s1 = FSequent(f1::f2::Nil, conclusion::Nil)
val s2 = FSequent(f1::f2::f3::f4::w1::Nil, conclusion::Nil)
val s3 = FSequent(f1::f2::f3::f4::Nil, conclusion::Nil)
val s4 = FSequent(f1::f2::f3::f4::w2::Nil, conclusion2::Nil)
val s5 = FSequent(f1::f2::f3::f4::Nil, conclusion2::Nil)
val s6 = FSequent(f1::f2::w1::Nil, conclusion::Nil)


exportTHF(List(s1), "ite-export-1-minimal.tptp", true)           //timeout
exportTHF(List(s2), "ite-export-1-with-witness.tptp", true)      //provable by leo 2, satallax, agsyhol
exportTHF(List(s3), "ite-export-1-without-witness.tptp", true)   //timeout
exportTHF(List(s4), "ite-export-2-with-witness.tptp", true)      //provable by leo 2, satallax
exportTHF(List(s5), "ite-export-2-without-witness.tptp", true)   //timeout
exportTHF(List(s6), "ite-export-1-withness-no-arith.tptp", true) //timeout
